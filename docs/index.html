<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>fitbit-settings-commons</title>
	<meta name="description" content="Documentation for fitbit-settings-commons">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.json" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">fitbit-settings-commons</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>fitbit-settings-commons</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#fitbit-settings-commons" id="fitbit-settings-commons" style="color: inherit; text-decoration: none;">
					<h1>fitbit-settings-commons</h1>
				</a>
				<p>Fitbit settings use React JSX that receives a <code>props</code> parameter. The JSX receives persisted settings from <code>props.settings</code>, and persists settings with <code>props.settingStorage</code>. In both cases the settings values must be strings. Values other than strings need to be &#39;packed&#39; into strings with <code>JSON.stringify()</code> and &#39;unpacked&#39; from strings with <code>JSON.parse()</code>. </p>
				<p>This library provides a wrapper to make it easier to work with Fitbit Setting API. Behind the scene, the wrapper &#39;packs&#39; and &#39;unpacks&#39; settings into / from strings, and persists to the <code>props.settingsStorage</code>, so that users don&#39;t need to do that in their codes. </p>
				<p>By default, &#39;packs&#39; always uses <code>JSON.stringify()</code> to encode settings, even if the value is a string, and &#39;unpacks&#39; always attempts to decode strings with <code>JSON.parse()</code> and, if that fails, return the strings as is. This default behaviour ensures that a value being packed and then unpacked would not change. However, if the value is a string, the stringified version of the string (i.e. wrapped in &quot;&quot;) is put inside the store. </p>
				<p>The packing and unpacking behaviours can be customised at general level or at individual property level. An unpacker at individual level can also act as an initializer, to provide a default value where no value is provided in <code>props.settings</code>.</p>
				<p>When using Typescript the wrapper uses a generic type variable to denote the setting&#39;s type, allowing the development tools to type checking and autocomplete the unpacked settings.</p>
				<a href="#usage" id="usage" style="color: inherit; text-decoration: none;">
					<h2>Usage</h2>
				</a>
				<p>See below. The code examples are provided in Typescript and TSX.</p>
				<a href="#install-the-library" id="install-the-library" style="color: inherit; text-decoration: none;">
					<h3>Install the library</h3>
				</a>
				<pre><code>npm i <span class="hljs-comment">--save fitbit-settings-commons</span></code></pre>
				<a href="#import-the-artifacts" id="import-the-artifacts" style="color: inherit; text-decoration: none;">
					<h3>Import the artifacts</h3>
				</a>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> {TypedSettingProps, ASIS, SettingsComponentProps, StringifyParseOptions} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fitbit-settings-commons&quot;</span></code></pre>
				<p>See <a href="docs/index.html">API document</a> for details.</p>
				<a href="#using-typedsettingprops-wrapper" id="using-typedsettingprops-wrapper" style="color: inherit; text-decoration: none;">
					<h3>Using TypedSettingProps Wrapper</h3>
				</a>
				<p>To use <code>TypedSettingProps</code> in typescript, it&#39;s preferrable to first define the settings type, for example:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> SettingType {
  stringVal?: <span class="hljs-built_in">string</span> ;
  stringConfusingVal_s?: <span class="hljs-built_in">string</span> ;
  numberVal?: <span class="hljs-built_in">number</span>;
  objVal?:
    | {
        stringProp: <span class="hljs-built_in">string</span>;
      }
    | <span class="hljs-literal">undefined</span>;
  arrayVal?: <span class="hljs-built_in">string</span>[] | <span class="hljs-literal">undefined</span>;
}</code></pre>
				<p>Then, at the begining of the Settings JSX, wrap the received <code>props</code> parameter with a new TypedSettingProps object. Later codes can then work with this wrapper instead of the <code>props</code> object directly.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> typedSetting : TypedSettingProps&lt;SettingType&gt;
    = <span class="hljs-keyword">new</span> TypedSettingProps(props);</code></pre>
				<a href="#accessing-the-unpacked-setting-values" id="accessing-the-unpacked-setting-values" style="color: inherit; text-decoration: none;">
					<h3>Accessing the unpacked setting values</h3>
				</a>
				<p>The <code>get()</code> method of the wrapper returns the unpacked settings. For example:</p>
				<pre><code>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>Property = typedSetting.<span class="hljs-keyword">get</span>().objVal?.<span class="hljs-built_in">string</span>Prop;
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">array</span>Element = typedSetting.<span class="hljs-keyword">get</span>().<span class="hljs-built_in">array</span>Val![<span class="hljs-number">1</span>];</code></pre>
				<a href="#updating-a-setting-by-putting-a-new-value" id="updating-a-setting-by-putting-a-new-value" style="color: inherit; text-decoration: none;">
					<h3>Updating a setting by putting a new value</h3>
				</a>
				<p>Use <code>update()</code> method to put new setting values or replace existing values. It receives an object as parameter, copies all enumerable own properties of the object to the unpacked settings (similar to <code>Object.assign()</code>), and persists the changes to <code>props.settingsStorage</code> behind the scene. </p>
				<p>For example:</p>
				<pre><code class="language-typescript">    typedSetting.update({
      stringVal:<span class="hljs-string">&quot;new string val&quot;</span>
    })</code></pre>
				<p>If SettingsType generic type is provided, the parameter of the <code>update()</code> method is typed. In typescript, type checking and autocomplete will be available to the parameter.</p>
				<pre><code class="language-typescript">    typedSetting.update({
      stringVal: <span class="hljs-number">42</span> <span class="hljs-comment">// error</span>
    })</code></pre>
				<a href="#updating-part-of-a-setting-object-or-array" id="updating-part-of-a-setting-object-or-array" style="color: inherit; text-decoration: none;">
					<h3>Updating part of a setting object or array</h3>
				</a>
				<p>If an <strong>existing</strong> setting value is an object or array, to update <strong>part</strong> of the value without replacing the whole object or array, use <code>getToUpdate()</code>. This method returns a tracked setting object. When accessing a property of the tracked setting object through a key, the key is marked as &#39;dirty&#39;, meaning it&#39;s assumed that the property is changed and needs to be persisted to <code>settingsStorage</code> later. In the end the <code>commit()</code> method of the wrapper needs to be called to persist all the &#39;dirty&#39; properties. For example: </p>
				<pre><code class="language-typescript">    typedSetting.getToUpdate().objVal!.stringProp = <span class="hljs-string">&#x27;new property&#x27;</span>;
    typedSetting.getToUpdate().arrayVal!.push(<span class="hljs-string">&#x27;new element&#x27;</span>);
    typedSetting.commit();</code></pre>
				<p>The returned tracked setting object is typed and readonly. Any property such as an object or array can be partially updated but not replaced. To set a property directly, use <code>update()</code>.</p>
				<a href="#updating-a-setting-asis" id="updating-a-setting-asis" style="color: inherit; text-decoration: none;">
					<h3>Updating a setting ASIS</h3>
				</a>
				<p>Another way of updating settings is to make the changes directly on the unpacked settings, then call <code>update()</code> with a constant <code>ASIS</code>, which is exported from this library as a marker to denote the changed properties. The value of the denoted property would be taken from the unpacked settings &quot;as is&quot;. </p>
				<p>For example, after partially changing the property <code>objVal</code>, the two callings of <code>update()</code> are equal, however using ASIS makes the method 1 shorter and less prone to error.</p>
				<pre><code class="language-typescript">    typedSetting.get().objVal!.stringProp = <span class="hljs-string">&quot;new string&quot;</span>;
    <span class="hljs-comment">// method 1</span>
    typedSetting.update({
      objVal: ASIS
    });    
    <span class="hljs-comment">// method 2</span>
    typedSetting.update({
      objVal: typedSetting.get().objVal
    });    </code></pre>
				<a href="#set-stringify-parse-behaviour" id="set-stringify-parse-behaviour" style="color: inherit; text-decoration: none;">
					<h3>Set Stringify Parse Behaviour</h3>
				</a>
				<p>The constructor of the wrapper <code>TypedSettingProps</code> can receive two additional optional parameters to customise the packing / unpacking / initialisation behaviour of the wrapper for individual setting keys as well as the default behaviour for all keys.</p>
				<pre><code class="language-typescript">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">private</span> props: SettingsComponentProps,
    <span class="hljs-keyword">private</span> packerUnpackers?: PackerUnpackerOption&lt;SettingsType&gt;,
    defaultPackerUnpacker?: DefaultPackerUnpackerOption
  </span>) </code></pre>
				<p>The parameter <code>packerUnpackers</code> customise wrapper&#39;s packing / unpacking / initialization behaviour for individual properties of the settings. The value should be an object with matching keys of the SettingsType. Under a matching key, &#39;packer&#39; and &#39;unpackInitiator&#39; can optionally be provided as functions. For example:</p>
				<pre><code class="language-typescript">  {
    stringConfusingVal: {
      packer: <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v,
      unpackInitiator: <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v
    }
  }</code></pre>
				<ul>
					<li>A packer function receives a value of the type of the matching SettingsType property and returns a string.</li>
					<li>An unpackInitiator receives a string or <code>undefined</code> and returns a value of the type of the matching SettingsType property. If an unpackInitiator is provided, but no setting is under the matching key in <code>props.settings</code>, the unpackInitiator will be called with <code>undefined</code>, acting as an initiator to return a default value for the key.</li>
				</ul>
				<p>The parameter <code>defaultPackerUnpacker</code> customise the default pack / unpack behaviour of the wrapper for all SettingsType properties. The value should be an object, with optional keys <code>packer</code> and / or <code>unpacker</code> providing the default packer / unpacker. Example value below sets a behaviour identical to the default behaviour of the wrapper.</p>
				<pre><code class="language-typescript">  {
    packer: <span class="hljs-built_in">JSON</span>.stringify,
    unpacker: jsonParseUnpackInitiator
  }</code></pre>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/typedsettingprops.html" class="tsd-kind-icon">Typed<wbr>Setting<wbr>Props</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/defaultpackerunpackeroption.html" class="tsd-kind-icon">Default<wbr>Packer<wbr>Unpacker<wbr>Option</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#asis" class="tsd-kind-icon">ASIS</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#nonundefined" class="tsd-kind-icon">Non<wbr>Undefined</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#packerunpackeroption" class="tsd-kind-icon">Packer<wbr>Unpacker<wbr>Option</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#settingscomponentprops" class="tsd-kind-icon">Settings<wbr>Component<wbr>Props</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#asis" class="tsd-kind-icon">ASIS</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#jsonparseunpackinitiator" class="tsd-kind-icon">json<wbr>Parse<wbr>Unpack<wbr>Initiator</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#stringifynonstring" class="tsd-kind-icon">stringify<wbr>Non<wbr>String</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
</body>
</html>