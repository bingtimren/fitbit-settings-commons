<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>fitbit-settings-commons</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">fitbit-settings-commons</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> fitbit-settings-commons</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#fitbit-settings-commons" id="fitbit-settings-commons" style="color: inherit; text-decoration: none;">
					<h1>fitbit-settings-commons</h1>
				</a>
				<p>Fitbit settings use React JSX that receives a <code>props</code> parameter. The JSX receives persisted settings from <code>props.settings</code>, and persists settings with <code>props.settingStorage</code>. In both cases the settings values must be strings. Values other than strings need to be &#39;packed&#39; into strings with <code>JSON.stringify()</code>. </p>
				<p>This library provides a wrapper to make it easier to work with Fitbit Setting API. The wrapper &quot;unpacks&quot; the values from <code>props.settings</code> when the values can be decoded by <code>JSON.parse()</code>, so that further codes can deal with the unpacked settings directly. Setting changes can be made to the unpacked settings. The wrapper &quot;packs&quot; the values that are not strings with <code>JSON.stringify()</code>, and persists to the <code>props.settingsStorage</code> behind the scene.</p>
				<p>When using Typescript the wrapper uses a generic type variable to denote the setting&#39;s type, allowing the development tools to type checking and autocomplete the unpacked settings.</p>
				<a href="#usage" id="usage" style="color: inherit; text-decoration: none;">
					<h2>Usage</h2>
				</a>
				<p>The code examples are provided in Typescript and TSX.</p>
				<a href="#install-the-library" id="install-the-library" style="color: inherit; text-decoration: none;">
					<h3>Install the library</h3>
				</a>
				<pre><code>npm i <span class="hljs-comment">--save fitbit-settings-commons</span></code></pre>
				<a href="#import-the-artifacts" id="import-the-artifacts" style="color: inherit; text-decoration: none;">
					<h3>Import the artifacts</h3>
				</a>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> {TypedSettingProps, ASIS, SettingsComponentProps, StringifyParseOptions} <span class="hljs-keyword">from</span> <span class="hljs-string">"fitbit-settings-commons"</span></code></pre>
				<a href="#using-settingscomponentprops" id="using-settingscomponentprops" style="color: inherit; text-decoration: none;">
					<h3>Using SettingsComponentProps</h3>
				</a>
				<p><code>SettingsComponentProps</code> is the type of the &#39;props&#39; parameter received by the settings JSX. It can be used in TSX to type the &#39;props&#39; parameter in typescript to provide autocomplete and type checking.</p>
				<pre><code class="language-tsx">function SettingsPage(props: SettingsComponentProps) {
    return (
      &lt;Page&gt;
        &lt;Section
          title={&lt;Text bold align=&quot;center&quot;&gt;Demo Settings&lt;/Text&gt;}&gt;
        &lt;/Section&gt;
      &lt;/Page&gt;
    );
  }

registerSettingsPage(SettingsPage);  </code></pre>
				<a href="#using-typedsettingprops-wrapper" id="using-typedsettingprops-wrapper" style="color: inherit; text-decoration: none;">
					<h3>Using TypedSettingProps Wrapper</h3>
				</a>
				<p>To use <code>TypedSettingProps</code> in typescript, it&#39;s preferrable to first define the settings type, for example:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> SettingType {
  stringVal?: <span class="hljs-built_in">string</span> ;
  stringConfusingVal_s?: <span class="hljs-built_in">string</span> ;
  numberVal?: <span class="hljs-built_in">number</span>;
  objVal?:
    | {
        stringProp: <span class="hljs-built_in">string</span>;
      }
    | <span class="hljs-literal">undefined</span>;
  arrayVal?: <span class="hljs-built_in">string</span>[] | <span class="hljs-literal">undefined</span>;
}</code></pre>
				<p>Then, at the begining of the Settings JSX, wrap the received <code>props</code> parameter with a new TypedSettingProps object. Later codes can then work with this wrapper instead of the <code>props</code> object directly.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> typedSetting : TypedSettingProps&lt;SettingType&gt;
    = <span class="hljs-keyword">new</span> TypedSettingProps(props);</code></pre>
				<a href="#accessing-the-unpacked-setting-values" id="accessing-the-unpacked-setting-values" style="color: inherit; text-decoration: none;">
					<h3>Accessing the unpacked setting values</h3>
				</a>
				<p>The <code>get()</code> method of the wrapper returns the unpacked settings. For example:</p>
				<pre><code>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>Property = typedSetting.<span class="hljs-keyword">get</span>().objVal?.<span class="hljs-built_in">string</span>Prop;
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">array</span>Element = typedSetting.<span class="hljs-keyword">get</span>().<span class="hljs-built_in">array</span>Val![<span class="hljs-number">1</span>];</code></pre>
				<a href="#updating-a-setting-by-putting-a-new-value" id="updating-a-setting-by-putting-a-new-value" style="color: inherit; text-decoration: none;">
					<h3>Updating a setting by putting a new value</h3>
				</a>
				<p>Use <code>update()</code> method to put new setting values or replace existing values. It receives an object as parameter, copies all enumerable own properties of the object to the unpacked settings (similar to <code>Object.assign()</code>), and persists the changes to <code>props.settingsStorage</code> behind the scene. </p>
				<p>For example:</p>
				<pre><code class="language-typescript">    typedSetting.update({
      stringVal:<span class="hljs-string">"new string val"</span>
    })</code></pre>
				<p>The parameter of the <code>update()</code> method is typed. In typescript, type checking and autocomplete will be available to the parameter.</p>
				<pre><code class="language-typescript">    typedSetting.update({
      stringVal: <span class="hljs-number">42</span> <span class="hljs-comment">// error</span>
    })</code></pre>
				<a href="#updating-part-of-a-setting-object-or-array" id="updating-part-of-a-setting-object-or-array" style="color: inherit; text-decoration: none;">
					<h3>Updating part of a setting object or array</h3>
				</a>
				<p>If an <strong>existing</strong> setting value is an object or array, to update <strong>part</strong> of the value without replacing the whole object or array, use <code>getToUpdate()</code>. This method returns a tracked setting object. When accessing a property of the tracked setting object through a key, the key is marked as &#39;dirty&#39;, meaning it&#39;s assumed that the property is changed and needs to be persisted to <code>settingsStorage</code> later. In the end the <code>commit()</code> method of the wrapper needs to be called to persist all the &#39;dirty&#39; properties. For example: </p>
				<pre><code class="language-typescript">    typedSetting.getToUpdate().objVal!.stringProp = <span class="hljs-string">'new property'</span>;
    typedSetting.getToUpdate().arrayVal!.push(<span class="hljs-string">'new element'</span>);
    typedSetting.commit();</code></pre>
				<p>The returned tracked setting object is typed and readonly. Any property such as an object or array can be partially updated but not replaced. To set a property directly, use <code>update()</code>.</p>
				<a href="#updating-a-setting-asis" id="updating-a-setting-asis" style="color: inherit; text-decoration: none;">
					<h3>Updating a setting ASIS</h3>
				</a>
				<p>Another way of updating settings is to make the changes directly on the unpacked settings, then call <code>update()</code> with a constant <code>ASIS</code> that is exported from this library as a marker to denote the changed properties. The value of the denoted property would be taken from the unpacked settings &quot;as is&quot;. </p>
				<p>For example, after partially changing the property <code>objVal</code>, the two callings of <code>update()</code> are equal, however using ASIS makes the method 1 shorter and less prone to error.</p>
				<pre><code class="language-typescript">    typedSetting.get().objVal!.stringProp = <span class="hljs-string">"new string"</span>;
    <span class="hljs-comment">// method 1</span>
    typedSetting.update({
      objVal: ASIS
    });    
    <span class="hljs-comment">// method 2</span>
    typedSetting.update({
      objVal: typedSetting.get().objVal
    });    </code></pre>
				<a href="#set-stringify-parse-behaviour" id="set-stringify-parse-behaviour" style="color: inherit; text-decoration: none;">
					<h3>Set Stringify Parse Behaviour</h3>
				</a>
				<p>As mentioned, when the wrapper extracts values from props.settings, wrapper calls <code>JSON.parse()</code> to extract non-string objects. When wrapper persists value into props.settingsStorage, wrapper calls <code>JSON.stringify()</code> to encode values into strings. Enum <code>StringifyParseOptions</code> provides three options to set the stringify/parse behaviour of the wrapper. </p>
				<p>To set a behaviour other than the default, pass a second parameter into the wrapper&#39;s constructor, for example:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> typedSetting : TypedSettingProps&lt;SettingType&gt;
    = <span class="hljs-keyword">new</span> TypedSettingProps(props, StringifyParseOptions.Stringify_NonString_Parse_Always);</code></pre>
				<p>The three options are:</p>
				<p><strong>Stringify_Always_Parse_Always [Default Option]</strong>: </p>
				<ul>
					<li>On update always JSON.stringify, even if value is a string (&#39;8&#39; would be set as &#39;&quot;8&quot;&#39; in storage);</li>
					<li>On unpacking always attempts JSON.parse, if fails then use the string as is;</li>
					<li>This is the default behaviour, it make sure values after packed / unpacked remain the same. However, string values will be put into props.settingsStorage as JSON as well, meaning the extra &#39;&quot;&#39; wrapping the strings.</li>
				</ul>
				<p><strong>Stringify_NonString_Parse_Always</strong>:</p>
				<ul>
					<li>On update only JSON.stringify non-string values;</li>
					<li>On unpacking always attempts JSON.parse;</li>
					<li>This option does not guarantee round-trip (&#39;8&#39; packed as &#39;8&#39; then unpacked as 8, a number)</li>
				</ul>
				<p><strong>Stringify_NonString_Parse_Key_Decide</strong>:</p>
				<ul>
					<li>On update only JSON.stringify non-string values;</li>
					<li>On unpacking, when key ends with &quot;_s&quot; or &quot;_S&quot; (indicating string value) does NOT attempt JSON.parse, otherwise attempts JSON.parse;</li>
					<li>This option works if you name the keys of string type values to end with &quot;_s&quot; or &quot;_S&quot;</li>
				</ul>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-enum">
						<a href="enums/stringifyparseoptions.html" class="tsd-kind-icon">Stringify<wbr>Parse<wbr>Options</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/typedsettingprops.html" class="tsd-kind-icon">Typed<wbr>Setting<wbr>Props</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-is-not-exported">
						<a href="globals.html#asis" class="tsd-kind-icon">ASIS</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#settingscomponentprops" class="tsd-kind-icon">Settings<wbr>Component<wbr>Props</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#asis" class="tsd-kind-icon">ASIS</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
				<li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>